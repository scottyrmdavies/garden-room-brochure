const canvas = document.getElementById('pageCanvas');
    const ctx = canvas.getContext('2d');
    const pNumDisplay = document.getElementById('pnum');
    
    // Spread mapping for 14 pages
    const spreads = [
        { left: "page1.jpg", right: "page2.jpg" }, 
        { left: "page3.jpg", right: "page4.jpg" },
        { left: "page5.jpg", right: "page6.jpg" },
        { left: "page7.jpg", right: "page8.jpg" },
        { left: "page9.jpg", right: "page10.jpg" },
        { left: "page11.jpg", right: "page12.jpg" },
        { left: "page13.jpg", right: "page14.jpg" }
    ];

    let currentSpread = 0;
    let isDragging = false;
    let activeSide = null;
    let cornerX = 0;
    let canvasW, canvasH;

    function init() {
        canvasW = canvas.offsetWidth;
        canvasH = canvas.offsetHeight;
        canvas.width = canvasW;
        canvas.height = canvasH;
        updateContent();
    }

    function draw() {
        ctx.clearRect(0, 0, canvasW, canvasH);
        if (!isDragging) return;

        const mid = canvasW / 2;
        ctx.save();

        if (activeSide === 'right') {
            // Forward Roll: Right to Left
            const rollWidth = (canvasW - cornerX) / 2;
            const rollX = cornerX + rollWidth;

            // This creates the "Round" Shadow Cylinder
            const grad = ctx.createLinearGradient(cornerX - 20, 0, cornerX + (rollWidth * 2), 0);
            grad.addColorStop(0, 'rgba(0,0,0,0)');
            grad.addColorStop(0.4, 'rgba(0,0,0,0.25)'); // Peak of the curve
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            
            ctx.fillStyle = grad;
            ctx.fillRect(cornerX - 40, 0, (canvasW - cornerX) + 40, canvasH);
        } else {
            // Backward Roll: Left to Right
            const rollWidth = cornerX / 2;
            const grad = ctx.createLinearGradient(0, 0, cornerX + 40, 0);
            grad.addColorStop(0, 'rgba(0,0,0,0)');
            grad.addColorStop(0.6, 'rgba(0,0,0,0.25)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, cornerX + 40, canvasH);
        }
        ctx.restore();
    }

    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        isDragging = true;
        activeSide = x > canvasW / 2 ? 'right' : 'left';
    });

    window.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const rect = canvas.getBoundingClientRect();
        cornerX = e.clientX - rect.left;
        
        const mid = canvasW / 2;
        const targetImg = activeSide === 'right' ? document.getElementById('right-img') : document.getElementById('left-img');
        
        // Calculate the roll reveal
        let ratio = activeSide === 'right' ? (cornerX - mid) / mid : (mid - cornerX) / mid;
        targetImg.style.opacity = Math.max(0, ratio);
        
        draw();
    });

    window.addEventListener('mouseup', () => {
        if (!isDragging) return;
        const mid = canvasW / 2;
        if (activeSide === 'right' && cornerX < mid && currentSpread < spreads.length - 1) currentSpread++;
        else if (activeSide === 'left' && cornerX > mid && currentSpread > 0) currentSpread--;

        isDragging = false;
        document.getElementById('left-img').style.opacity = 1;
        document.getElementById('right-img').style.opacity = 1;
        updateContent();
        ctx.clearRect(0, 0, canvasW, canvasH);
    });

    function updateContent() {
        document.getElementById('left-img').src = spreads[currentSpread].left;
        document.getElementById('right-img').src = spreads[currentSpread].right;
        pNumDisplay.innerText = (currentSpread + 1) + " of " + spreads.length;
    }

    window.onload = init;
